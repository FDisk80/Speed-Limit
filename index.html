<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Real-Time Speed Limit</title>
    <link rel="manifest" href="manifest.json">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@900&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000000;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
        }

        /* Vertical animation */
        @keyframes full-bob-vertical {
            0% { transform: translateY(0); }
            25% { transform: translateY(calc(50vh - 50% - 15px)); }
            50% { transform: translateY(0); }
            75% { transform: translateY(calc(-50vh + 50% + 15px)); }
            100% { transform: translateY(0); }
        }
        
        /* Horizontal animation */
        @keyframes full-bob-horizontal {
            0% { transform: translateX(0); }
            25% { transform: translateX(calc(50vw - 50% - 15px)); }
            50% { transform: translateX(0); }
            75% { transform: translateX(calc(-50vw + 50% + 15px)); }
            100% { transform: translateX(0); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 30px rgba(255, 255, 255, 0.3); }
            50% { transform: scale(1.05); box-shadow: 0 0 45px rgba(100, 255, 100, 0.7); }
            100% { transform: scale(1); box-shadow: 0 0 30px rgba(255, 255, 255, 0.3); }
        }

        .sign-container {
            width: 90vmin;
            height: 90vmin;
            max-width: 450px;
            max-height: 450px;
            position: absolute;
        }

        /* Classes to apply orientation-specific animations */
        .bob-vertical {
            animation: full-bob-vertical 600s ease-in-out infinite;
        }
        .bob-horizontal {
            animation: full-bob-horizontal 600s ease-in-out infinite;
        }

        .speed-sign {
            width: 100%;
            height: 100%;
            background-color: white;
            border-radius: 50%;
            border: 15px solid #d90429;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            text-align: center;
        }
        
        .sign-pulse .speed-sign {
            animation: pulse 0.5s ease-out;
        }

        #speed-limit {
            font-weight: 900;
            color: #000000;
            box-sizing: border-box;
        }
        
        /* Default font sizes (Portrait) reduced */
        .font-size-large {
            font-size: 60vmin;
            line-height: 1; 
        }
        
        .font-size-medium {
            font-size: 44vmin;
            line-height: 1; 
        }
        
        /* Media query with balanced font sizes for landscape */
        @media (orientation: landscape) {
            .font-size-large {
                font-size: 58vmin;
            }
            .font-size-medium {
                font-size: 43vmin;
            }
        }
        
        .error-text {
            font-size: 25vmin !important;
        }
        
    </style>
</head>
<body>

    <div class="sign-container">
        <div class="speed-sign">
            <span id="speed-limit">...</span>
        </div>
    </div>
    
    <script>
        const speedLimitElement = document.getElementById('speed-limit');
        const signContainerElement = document.querySelector('.sign-container');
        let lastKnownSpeed = null;
        let watchId = null;
        let wakeLock = null;
        // NEW: Timer to handle temporary signal loss (like in tunnels)
        let noSignalTimer = null;

        const requestWakeLock = async () => {
          if ('wakeLock' in navigator) {
            try {
              wakeLock = await navigator.wakeLock.request('screen');
              wakeLock.addEventListener('release', () => console.log('Screen Wake Lock was released'));
              console.log('Screen Wake Lock is active');
            } catch (err) {
              console.error(`Wake Lock Error: ${err.name}, ${err.message}`);
            }
          }
        };

        const toggleFullScreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        };

        // UPDATED: More accurate data fetching logic
        async function fetchSpeedLimit(lat, lon) {
            const overpassApiUrl = 'https://overpass-api.de/api/interpreter';
            // This new query finds the ONE nearest road within a more precise 25 meters.
            const query = `
                [out:json][timeout:10];
                way(around:25,${lat},${lon})[highway];
                (._;>;);
                out tags;`;
            
            try {
                const response = await fetch(`${overpassApiUrl}?data=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error(`API query failed: ${response.status}`);
                const data = await response.json();

                if (data.elements.length > 0) {
                    const roadElement = data.elements.find(el => el.type === 'way');
                    if (roadElement && roadElement.tags) {
                        const tags = roadElement.tags;
                        if (tags.maxspeed) {
                            console.log("Found explicit speed limit:", tags.maxspeed);
                            return tags.maxspeed;
                        }
                        if (tags.highway) {
                            console.log("No explicit speed. Estimating from road type:", tags.highway);
                            switch (tags.highway) {
                                case 'motorway': return '110';
                                case 'trunk': return '90';
                                case 'primary': return '80';
                                case 'secondary': return '70';
                                case 'tertiary': return '60';
                                case 'residential':
                                case 'unclassified':
                                case 'living_street':
                                    return '50';
                                default: return null;
                            }
                        }
                    }
                }
                return null;
            } catch (error) {
                console.error("Error fetching speed limit:", error);
                return null;
            }
        }

        function updateDisplay(speed, isInitialCall = false) {
            speedLimitElement.classList.remove('error-text');
            
            if (isInitialCall || speed !== lastKnownSpeed) {
                signContainerElement.classList.add('sign-pulse');
                setTimeout(() => signContainerElement.classList.remove('sign-pulse'), 500);

                const speedText = speed || '--';
                speedLimitElement.textContent = speedText;
                lastKnownSpeed = speed;
                speedLimitElement.classList.remove('font-size-large', 'font-size-medium');
                
                if (speedText.toString().length >= 3) {
                    speedLimitElement.classList.add('font-size-medium');
                } else {
                    speedLimitElement.classList.add('font-size-large');
                }
            }
        }
        
        // UPDATED: Smarter logic to handle signal loss
        async function processLocation(position) {
            const { latitude, longitude } = position.coords;
            console.log(`Watcher reported new position: ${latitude}, ${longitude}`);
            const speed = await fetchSpeedLimit(latitude, longitude);

            if (speed) {
                // If we get a good speed, clear any signal loss timer and update.
                if (noSignalTimer) {
                    clearTimeout(noSignalTimer);
                    noSignalTimer = null;
                }
                updateDisplay(speed);
            } else {
                // If we get a bad reading (null), we don't immediately show '--'.
                // We only start a timer if one isn't already running.
                if (!noSignalTimer) {
                    console.log("No speed data. Starting 15s timer before showing '--'.");
                    noSignalTimer = setTimeout(() => {
                        console.log("Timer elapsed. No new signal. Showing '--'.");
                        updateDisplay(null); // Now update to '--' after the delay
                        noSignalTimer = null; 
                    }, 15000); // 15-second delay before showing "--"
                }
            }
        }

        function locationError(error) {
            console.error(`Geolocation error: ${error.message} (Code: ${error.code})`);
            if (error.code === error.PERMISSION_DENIED) {
                stopWatcher(); 
                speedLimitElement.classList.add('error-text');
                speedLimitElement.textContent = "DENIED";
            }
        }

        function startWatcher() {
            if (!('geolocation' in navigator)) return; 
            if (watchId === null) { 
                console.log("Starting location watcher...");
                watchId = navigator.geolocation.watchPosition(
                    processLocation,
                    locationError,
                    { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
                );
            }
        }

        function stopWatcher() {
            if (watchId !== null) {
                clearTimeout(noSignalTimer); // Clear timer if we stop the watcher
                noSignalTimer = null;
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                console.log("Location watcher paused.");
            }
        }
        
        const handleOrientationChange = () => {
            const isPortrait = screen.orientation.type.startsWith('portrait');
            console.log(`Orientation changed. Is Portrait: ${isPortrait}`);

            if (isPortrait) {
                console.log('Applying vertical animation.');
                signContainerElement.classList.remove('bob-horizontal');
                signContainerElement.classList.add('bob-vertical');
            } else {
                console.log('Applying horizontal animation.');
                signContainerElement.classList.remove('bob-vertical');
                signContainerElement.classList.add('bob-horizontal');
            }
        };

        function handleVisibilityChange() {
            if (document.hidden) {
                stopWatcher();
            } else {
                startWatcher();
                requestWakeLock();
            }
        }
        
        function startApp() {
            if (!('geolocation' in navigator)) {
                speedLimitElement.textContent = "N/A";
                return;
            }
            
            updateDisplay(null, true);
            startWatcher();
            requestWakeLock();
            
            document.body.addEventListener('click', toggleFullScreen);
            
            handleOrientationChange();
            if (screen.orientation && screen.orientation.addEventListener) {
                screen.orientation.addEventListener('change', handleOrientationChange);
            } else {
                window.addEventListener('resize', handleOrientationChange);
            }

            setTimeout(() => {
                if (!document.fullscreenElement) {
                   console.log("Attempting to enter fullscreen automatically.");
                   toggleFullScreen();
                }
            }, 1000);

            document.addEventListener('visibilitychange', handleVisibilityChange, false);
        }

        window.onload = startApp;
    </script>
    <!-- Script to register the service worker -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js').then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          }, err => {
            console.log('ServiceWorker registration failed: ', err);
          });
        });
      }
    </script>
</body>
</html>
